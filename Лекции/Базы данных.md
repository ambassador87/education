**Q: Медленный запрос, что делать?**

A: Если запрос медленный, можно:
- использовать индексы, чтобы поиск, сортировка по полям были быстрее
- воспользоваться EXPLAIN ANALYZE, чтобы понять, где могут быть потери по времени
- шардирование, для масштабирования БД, чтобы распределить нагрузку между несколькими серверами

**Q: Что такое СУБД? Какие бывают типы?**

A: Система управления базами данных - это посредник между пользователем и данными
 СУБД поздраделяются на:
 1. **Реляционные**.
     Самый распространненый тип, в котором данные хранятся в виде связанных таблиц. Для работы с ними используется язык SQL. Пример: PostgreSQL, MySQL, Oracle, Microsoft SQL Server
2. **Нереляционные (NoSQL)**. 
    Для хранения неструктурированных данных (текстов, видео, логов) и огромных нагрузок.
    - *Документоориентированные*: хранят данные в виде документов (JSON). *MongoDB*
    - *Ключ-значение*: работают как словарь (самые быстрые). *Redis*
    - *Графовые*: хранят данные в виде узлов и связей между ними. Идеально для соцсетей.
3. **Иерархические**.
   В наше время практически не используются, так очень стары

**Q: ACID**

A: ACID - это четыре главных свойства транзакций в реляционных БД.
1. **Атомарность (Atomacity)**. 
   Транзакция это единица работы с БД. Транзакция объединяет несколько операций, при этом выполняется как одно целое. Она либо выполняется полностью, либо не выполняется совсем. 
   Транзакция считается успешной только, когда изменения были зафиксированы командой *COMMIT;* В ином случае происходит откат (ROLLBACK) и все изменения отменяются.
2. **Согласованность (Consistency)**.
    БД должна находится в корректном состоянии до и после транзакции, т.е. данные соответствуют схеме и ограничениям (constraints). 
    - *Constraints* . Если транзакция нарушает хотя бы одно правило, она откатывается. Например, поле может быть только положительным целым числом и не может быть NULL. Значит, при попытке записать в поле строку, отрицательное число или число с плавающей точкой или NULL, произойдет откат транзакции. 
    - *Логическая согласованность*. Если мы переводим сумму с одного счета на другой, значит на одном счете сумма уменьшается, а на другом увеличивается на то же самое значение.
    - *Каскадное удаление*. Если удаляется пользователь, значит удаляются все его комментарии, чтобы в БД не было сиротских записей.
3. *Изоляция (Isolation)*. Принцип говорит, что транзакции, выполняющиеся одновременно не должны влиять на результаты друга друга, не должны видеть промежуточные результаты других транзакций и выполняться так, будто каждая транзакция единственная. Результат работы параллельных транзакций должен быть таким, как если бы они выполнялись последовательно.
4. **Устойчивость/Надежность (Durability)**. 
    Этот принцип гарантирует, что после того, как транзакция зафиксирована в базе данных, она остается в ней навсегда, даже в случае сбоя системы. Это обеспечивается за счет механизмов резервного копирования и журналов транзакций, которые можно использовать для восстановления.

**Q: Уровни изоляции транзакций**

A: Четыре уровня изоляции:
 - **Read Uncommited**. Самый слабый  уровень изоляции, который позволяет транзакциям видеть промежуточные состояния записей параллельно выполняющихся транзакций до того, как они были зафиксированы. Эта проблема называется **грязным чтением** (dirty reading). Отсутствует в PostgresSQL, но есть в MySQL, MS SQL, Oracle
 - **Read Commited**. Транзакции не могут видеть промежуточные результаты других транзакций, выполняющихся одновременно, пока они не будут зафиксированы.
   На этом уровне существуют две проблемы: неповторяющееся чтение и фантомное чтение
   
	***Неповторяющееся чтение*, когда в процессе неоднократного чтения записи в рамках одной транзакции, эта запись может быть изменена другой транзакцией. Таким образом результаты чтения записи в транзакции будут отличаться.***

	***Фантомное чтение*, когда транзакция делает выборку записей, но в процессе ее выполнения в базу добавляются одна или несколько записей, которые  критически важны для первой транзакции, но не учтены ею***
	  
	Реализация этого уровня в PostgreSQL. В случае UPDATE создаются новые записи, а старые помечаются, как удаленные. Но пока транзакция не зафиксирована (COMMIT) база игнорирует эти пометки и новые записи и отдает только старые.
	 В MySQL, MS SQL Server, Oracle сохраняет старые данные в Undo Log и его аналоги, перед тем как внести изменения. Эти данные используются в случае отката и для чтения другими транзакциями пока изменения не зафиксированы.
- **Reapetable Read**. Гарантирует, что в случае повторного чтения данные не изменятся в пределах одной транзакции. База делает снимок данных перед началом транзакции и использует только их (MVCC).
  В случае если две транзакции читают данные, для последующего изменения, одна из них захватывает блокировку строки и создает новую версию записи. Вторая транзакция продолжает видеть старую версию записи в рамках своего снапшота. После фиксации изменений первой транзакции, вторая пытается перезаписать строку, СУБД обнаруживает, что строка была изменена после начала транзакции и завершает ее ошибкой сериализации (serialization error). 
  Пропускает ошибку write skew.  RR не ловит эту ошибку, т.к. меняются разные строки, а не одна общая для двух транзакций. Ошибка на уровне логики, условия, а не в совместном доступе к одной записи. Обе транзакции легальны и могут коммититься одновременно. Пример с двумя докторами, которым нужно уйти в отпуск по очереди, а не одновременно.    
- **Serializable**. Наивысший уровень изоляции. Все параллельные транзакции должны вести себя так, будто выполняются строго по очереди. 
  Предотвращает проблему *write skew*.
  ***Write Skew - ошибка, когда две транзакции принимают решения на основе одного и того же snapshot, но изменяют разные строки, нарушая общий инвариант.
  Каждая транзакция по отдельности корректна, но совокупный результат нарушает условие. 
  Пример: два доктора должны уйти в отпуск по отдельности.
  T1: Select Врач 1 = не в отпуске, врач 2 = не в отпуске. Update Врач 1 = отпуск
  Т2: Select Врач 1 = не в отпуске, врач 2 = не в отпуске. Update Врач 2 = отпуск
  Результат: оба врача уходят в отпуск. Но если выполнять, транзакции последовательно, в отпуск уйдет только один и условие во второй транзакции не позволит отпустить доктора в отпуск.***

**Q: Что делает GROUP BY?**

A: Оператор SQL, который группирует строки с одинаковым значениями в одну группу, чтобы к каждой группе можно было применить агрегатные функции.
Например, мы делаем запрос к таблице products, и группируем товары по производителю
vendor. Таким образом у нас получится не 1000 наименований товаров, а 100 групп по наименованию вендора, где каждая строка аккумулирует в себе данные товаров, относящихся к одной группе.

**Q: HAVING и WHERE в SQL?**

A: `WHERE` фильтрует строки по условию до группировки, а `HAVING` фильтрует группы, применяя условия к агрегированным данным.
`WHERE` нельзя использовать с агрегатными функциями
Пример: 
```sql
SELECT vendors.id, SUM(products.price * products.number) AS total
FROM vendors
JOIN products ON vendors.id = products.vendor_id
GROUP BY vendors.id
HAVING SUM(products.price * products.number) >= 1000000;
```

**Q: Гонка транзакций (Transaction Race)**

А: Гонка транзакций - это класс проблем конкурентного доступа. Результат выполнения транзакции зависит от порядка и времени выполнения других параллельных транзакций. Проявляется в виде частных случаев: грязного чтения, неповторяющегося чтения, фантомного чтения, потери обновления, логических конфликтов записи.

**Q: Индексы. Какие бывают? Примеры из жизни!**

A: Индексы - это структуры данных для ускорения поиска и извлечения данных из таблицы. Индексы очень ускоряют операции чтения, но при этом замедляют операции вставки, обновления и удаления данных.
Селективность индекса - показатель того, насколько хорошо индекс позволяет сузить круг возможных строк, которые нужно проверить.

**Высокая селективность** индекса означает, что по нему можно быстро найти небольшое количество строк (для современных СУБД 5-15%)
**Низкая селективность** означает, что по индексу будет найдено большое число строк и чтение этих строк становится очень затратным по сравнению с последовательным чтением напрямую из базы. Все дело в оверхедах. Чтобы прочитать данные из индекса, нужно попасть в индекс на диске, потом скакнуть в таблицу к записи, прочитать ее, и снова в индекс. Такое скачкообразное чтение очень затратно, в то время как последовательное чтение идет блоками подряд. Поэтому если селективность индекса >15%, то СУБД может отказаться от индекса.

Чтобы сделать селективность более высокой, можно сделать:

**Cоставной индекс**
Индекс по нескольким полям, по которым будет фильтроваться выборка в `WHERE`
```sql
CREATE INDEX idx_user_city_age ON users (city, age)

SELECT first_name, last_name 
FROM customer 
WHERE city='Moscow' AND age BETWEEN 30 and 40;
```
**Зачем нужен:** Чтобы сузить поиск. По отдельности `city` может быть много и `age` много, но мужчин в от 30 до 40 сильно уменьшает выборку.

**Покрывающий индекс** 
Это индекс, который содержит в себе дополнительные данные, нужные вашему `SELECT`. База видит, что все данные есть в индексе, и вообще не трогает основную таблицу (это называется **Index Only Scan**). То есть не будет множества прыжков из индекса в таблицу.
```sql
CREATE INDEX idx_user_email_covered ON users (email) INCLUDE (name, phone);

SELECT name, phone FROM users WHERE email = 'test@test.com'
```

**Q: B-Tree Index как устроен и где используется?**

A:  **B-Tree (Balanced Tree, сбалансированное дерево)** — это структура данных в виде дерева, где:    
    - Все **листья находятся на одном уровне** (сбалансировано)        
    - В каждой **ветви хранятся ключи**, по которым можно быстро находить нужное значение
        
Благодаря этому поиск, вставка и удаление работают примерно за **O(log n)**, даже для больших таблиц.  
#### Как устроен индекс в СУБД

- Корень дерева → ветви → листья    
- **Листовые узлы** содержат:    
    - значения ключей (например, `city`, `age`)        
    - указатели на строки таблицы или на их физические адреса        
- Внутренние узлы → помогают быстро найти лист, где находится нужное значение
#### Где используется

- **B-Tree индекс** оптимален для:    
    - **Равенства**: `WHERE city='Moscow'`        
    - **Диапазонов**: `WHERE age BETWEEN 30 AND 40`        
    - **Сортировки**: `ORDER BY city, age`        
    - **Группировки**: `GROUP BY city, age`

**Q: Классический вопрос B-Tree индекс и Hash индекс сравнить или выбрать что использовать**

A: **B-Tree индекс:**

1. **Применение**: B-Tree индекс подходит для индексации данных, которые используются в равенственных и диапазонных операциях сравнения (например, _**=, <, >, BETWEEN**_).
2. **Поиск**: B-Tree индекс обеспечивает эффективный поиск данных, особенно когда требуется точное совпадение. logN
3. **Сортировка**: B-Tree индекс поддерживает сортировку данных и ускоряет выполнение операций **ORDER BY**.
4. **Пример использования**: Индексация столбцов, содержащих числовые и текстовые данные, идентификаторы, даты и времена, а также другие данные, используемые в сравнении и сортировке.

**Hash индекс:**

1. **Применение**: Hash индекс подходит для индексации данных, когда требуется быстрый поиск точного совпадения (**равенственные** операции).
2. **Поиск**: Hash индекс обеспечивает поиск данных за постоянное время (O(1)) для точных совпадений.
3. **Сортировка**: Hash индекс не поддерживает сортировку данных, и он не может быть использован для диапазонных запросов.
4. **Пример использования**: Индексация столбцов с уникальными значениями, такими как идентификаторы сущностей или хеши.

**Когда использовать B-Tree индекс:**

- Когда требуется индексировать столбцы для поиска по точному значению или диапазону значений.
- Когда нужна поддержка сортировки данных.
- Когда индексируемые данные имеют повторяющиеся значения.

**Когда использовать Hash индекс:**

- Когда требуется индексировать столбцы для точного поиска по уникальным или практически уникальным значениям.
- Когда запросы основаны на равенственных операциях и не требуют сортировки или диапазонных запросов.
- Когда хеширование данных имеет смысл, например, для быстрого поиска по хеш-коду.

**Q: Составной индекс**

A: Составной индекс это индекс на основе нескольких столбцов. Поиск одновременно по нескольким столбцам сужает выборку и повышает селективность индекса. Порядок полей в индексе и в запросе должен соответствовать, т.е. первое поле в индексе, должно быть первым и внутри запроса при сортировке, фильтрации и группировке
Составной индекс может базироваться сразу на тех столбцах, которые нужны для выполнения запроса, без обращения к основной таблице.

```sql
CREATE INDEX idx_customer_order_date ON orders (customer_id, order_date) WHERE orders.is_active is TRUE;
```
