**1 Часть. 13 всего 36**

**Какие типы данных есть в Python?**
Неизменяемые (простые типы): числа (целые, вещественные, комплексные), логические (True, False), строки (упорядоченные), кортежи (упорядоченные), NoneType (обозначает отсутствие значения), фрозенсет.

Изменяемые (составные типы): списки (упорядоченные), множества (неупорядоченные), словари (упорядоченные).

Если классифицировать, какие упорядоченные, а какие нет?
Неупорядоченные только множества.

В чем отличие изменяемых и неизменяемых типов данные в разрезе затрат памяти и ресурсов? 
Python не всегда заранее знает, сколько памяти нужно выделить, поэтому приходится динамически перераспределять память — "перекладывать" объекты в новую область памяти при необходимости, что ведет к дополнительным расходам. Питону не понятно, сколько нужно выделить памяти под изменяемые типы, и ему приходится их каждый раз перекладывать, это дополнительные расходы.




**Кто не может быть ключом в дикте?**
Хэшируемость. Хэшируем объект – объект, у которого есть неизменяемый хэш-значения, получаемое через функцию hach(). Это значение должно быть константным в течении жизни объекта. Следовательно, ключом могут быть только хэшируемые (неизменяемые) типы данных.

Неизменяемые – хэшируемые.
Изменяемые – нехэшируемые.


**Что такое lambda функция?**
Это анонимная, однострочная функция, может принимать неограниченное количество аргументов, содержит неявный return, т.е возвращает то выражение, которое было вычислено.



**Контекстные менеджеры?**
Механизм для управления ресурсами (например, файлами, соединениями с базами данных), который автоматически выполняет действия до и после использования ресурса. Это помогает избежать утечек ресурсов и улучшает читаемость кода. Ключевое слово: with.

Работает следующим образом. Открывает ресурс и настраивает его. Предоставляет доступ к ресурсу, автоматически закрывает ресурс и освобождает ресурс, даже если в момент работы произошла ошибка.

КМ реализует два магических метода, __enter__ выполняется при входе в блок with и __exit__ выполняет при выходе из блока with.

Используется при работе с файлами (автоматические закрытие файлов), работа с соединениями (закрытие соединения с бд), работа с блокировками (авто снятие блокировок в многопоточности), управление ресурсами (очистка памяти, временные файлы и т.д.).

Преимущества. Удобство (автоматические освобождение ресурса), надежность (ресурсы освобождаются даже при ошибке), чистота кода (читаемый и структурированный). 


Какими способами можно реализовать КМ?
Класс, with, try-finally, Асинхронный контекстный менеджер (__aenter__, __aexit__), через декоратор @contextmanager импортировав библиотеку @contextlib с использованием генератора.

**Что такое Исключения? Какова Иерархия исключений?**

Механизм, который обрабатывает ошибки и исключительные ситуации, предотвращая аварийное завершение программы. 

В блок try помещается код, который может вызвать исключение. 

Блок except необходим для обработки исключений.  

Блок else выполняется если исключение не произошло. 

Блок finally выполняется независимо от исключения.

1. BaseException: Базовый класс для всех исключений. Его использование не рекомендуется для обработки стандартных ошибок. 
2. Exception: Основной класс для всех классов исключений, которые не соответствуют системным исключениям (ZeroDivisionError, ValueError, TypeError, KeyError).

Иерархия исключений в Python организована в виде дерева наследования, корнем которого является базовый класс BaseException. От него наследуются все остальные исключения.


**Что такое итератор?**
Поведенческий паттерн проектирования, позволяет последовательно обходить сложную коллекцию, без раскрытия деталей ее реализации.

Особенности: он знает где находится, работает с любым количеством элементов, заканчивается, когда элементы заканчиваются (StopIteration).

Итерируемый объект – который можно перебирать. У него есть метод __iter__ или __get_item__.

Итератор – объект, который возвращает по одному элементу за раз. У него есть метод __next__.

Итерация – последовательный перебор элементов.


**Что такое генератор?**
Генератор — это вид итератора, который создается с помощью функции с ключевым словом yield. При каждом вызове yield генератор возвращает следующий элемент и приостанавливает выполнение, сохраняя свое состояние, чтобы при следующем вызове продолжить с того же места.

Особенности: 

- Ленивое вычисление: элементы создаются по одному "на лету", не занимая память под всю коллекцию целиком.
- Экономия памяти: хранится только текущее состояние и возвращаемый элемент, подходя для работы с большими или бесконечными последовательностями.
- Поддержка бесконечных последовательностей, так как не нужно заранее знать весь набор значений.

Можно ли вложить один генератор в другой?

Да, в Python можно вложить один генератор в другой. Это называется вложенными генераторами или генераторами генераторов

Основные способы вложения генераторов:

1. Прямое вложение с помощью yield
1. Использование yield from для делегирования
1. Создание генераторов высшего порядка

yield from - это специальный синтаксис в Python для работы с генераторами, который позволяет элегантно делегировать генерацию значений другому генератору или итерируемому объекту.

Что происходит под капотом:

1. yield from разворачивает итерируемый объект
1. Автоматически обрабатывает подключение и отключение генераторов
1. Может передавать значения и исключения между генераторами

**Что такое тернарный оператор?**
Это сокращённый способ записи условного выражения. Он позволяет провести проверку условия и вернуть одно из двух значений. 


**Чем отличается == от is?**
== (равенство) сравнивает *значения* объектов, а is сравнивает ссылки в памяти (проверяет *идентичность* объектов).

Оператор == сравнивает значения объектов, то есть проверяет равенство содержимого. Если два объекта имеют одинаковые данные, то == вернет True, даже если они находятся в разных местах памяти.

Оператор is проверяет идентичность объектов, то есть указывает, ссылаются ли две переменные на один и тот же объект в памяти. is возвращает True только если обе переменные указывают на один и тот же объект.

**List comprehension?**
Создание списков через короткое выражение.
List comprehension — это сокращённый и удобный способ создать новый список, используя короткое выражение с циклом for внутри квадратных скобок. Он позволяет сгенерировать элементы нового списка на основе существующего и при необходимости сразу применить к элементам выражение или фильтр (условие).


**list, tuple что такое? в чем отличия?**
Списки vs кортежи

- Изменяемые – неизменяемые. Списки изменяемы, кортежи неизменяемы.
- Изменяемые методы – неизменяемые методы. Списки имеют методы для изменения (append, remove и др.), кортежи — ограниченный набор неизменяемых методов (count, index).
- Скорость ниже – скорость выше. Доступ к элементам и работа с кортежами обычно быстрее.
- Занимают больше памяти – меньше памяти. Кортежи занимают меньше памяти, поскольку являются неизменяемыми.
- Квадратные скобки – круглые скобки.
  Списки создаются с квадратными скобками [], кортежи — с круглыми () или просто запятой без скобок.


**Производительность**

- Кортеж: быстрее и занимает меньше памяти
- Лист: требует больше ресурсов из-за изменяемости

**Использование**

- Лист: для коллекций, которые могут меняться
- Кортеж: для фиксированных наборов данных, ключей словарей

**Память:**

- Кортеж: требует меньше памяти (фиксированный размер)
- Лист: требует больше из-за изменяемости (дополнительная память для возможности роста)





**Сравнить лист и кортеж. О(большое), отличия работы в памяти** 

- Оба являются последовательностями для хранения элементов
- Оба поддерживают индексацию, срезы и итерацию
- Оба могут хранить элементы разных типов

**Общие операции:**

- Доступ по индексу: O(1) для обоих
- Поиск элемента: O(n) для обоих
- Срезы: O(k) для обоих (k - размер среза)
- Итерация: O(n) для обоих

**Операции только для листа:**

- Вставка элемента (insert): O(n) - требует сдвига элементов
- Удаление элемента: O(n) - требует сдвига элементов
- Изменение элемента: O(1)
- Изменение размера: O(n) - при необходимости перераспределения памяти
- Добавление элемента в конец списка(append): O(1)
  Добавление элемента в конец списка (append) в Python происходит следующим образом:
1. При вызове метода append() проверяется, достаточно ли свободного места в текущем выделенном блоке памяти списка для нового элемента.
1. Если места достаточно, новый элемент просто помещается в конец списка — операция выполняется за O(1).
1. Если места недостаточно, происходит перераспределение памяти:

Выделяется новый блок памяти большего размера (обычно примерно в 1.125 раза больше для маленьких списков, для больших — ближе к удвоению).

Существующие элементы копируются в этот новый блок памяти (операция O(n)).

Добавляется новый элемент.

1. Перераспределение памяти происходит не при каждом добавлении, а редко, что обеспечивает амортизированную сложность append равную O(1) в среднем.

Что будет если список заполнится?
Хотя часто говорят, что размер списка увеличивается в два раза, на самом деле в CPython размер выделяемой памяти растет примерно в 1.125 раза для небольших списков и может приближаться к удвоению для больших. Конкретный коэффициент зависит от состояния списка и версии интерпретатора.
Процесс расширения списка при заполнении:

1. Выделяется новый блок памяти большего размера, чем текущий.
1. Все элементы копируются из старого блока в новый.
1. Старый блок памяти освобождается.
1. Новый элемент добавляется в выделенное место.



**Sets, tuples что такое? в чем отличия?**
Множество vs кортежи

Изменяемые – неизменяемые

Не содержат дубликаты – содержат дубликаты

Неупорядоченные – упорядоченные

Использует фигурные скобки - круглые скобки

Нельзя обращаться по индексу – можно обращаться по индексу

Для хранения уникальных элементов - для группировки связанных данных



**Что такое SOLID?**

Это набор принципов, помогающих писать устойчивый и поддерживаемый объектно-ориентированный код.

S — Принцип единственной ответственности. Каждый класс должен заниматься только одной задачей. Это облегчает понимание и изменение кода. Ящик под каждый тип одежды.

O — Принцип открытости/закрытости. Код должен быть написан так, чтобы его можно было расширить, не меняя уже существующий. Добавить ящики без изменения планировки шкафа.

L — Принцип замены Барбары Лисков. Классы-наследники должны вести себя так же, как и их базовый класс, чтобы программа работала правильно. Любой ящик шкафа должен правильно хранить вещи, как и любой другой ящик, чтобы можно было их заменить без проблем.

I — Принцип разделения интерфейсов. Лучше создавать несколько небольших интерфейсов, чем один сложный. Лучше иметь несколько маленьких ящиков для разных типов одежды, чем один большой ящик, где все смешано.

D — Принцип инверсии зависимостей. Программа должна зависеть от общих правил (абстракций), а не от конкретных реализаций. Шкаф должен позволять использовать ящики разных производителей, а не зависеть от конкретного бренда ящика.


**Магический метод __init__?**

**__init__— Инициализация объекта**

Это метод, который используется для инициализации объектов класса, вызывается сразу после создания нового экземпляра класса. Первый параметр self — это ссылка на создаваемый объект, а остальные параметры — это аргументы для инициализации атрибутов объекта.

Отвечает за **инициализацию** объекта после его создания.

Здесь задаются начальные значения атрибутов объекта.
Магический метод**init**в Python — это инициализатор объекта, который автоматически вызывается сразу после создания экземпляра класса. Его основная задача — инициализировать атрибуты объекта и подготовить его к использованию. Метод принимает в качестве первого параметра self (ссылку на сам объект), а также может принимать дополнительные аргументы, которые передаются при создании объекта.


**2 часть. 9**

**Python — это императивный или декларативный язык?**

Императивный стиль — это стиль написания кода в виде набора последовательных инструкций (команд) с активным использованием переменных. Отвечает на вопрос как достичь нужного результата?

Декларативный стиль программирования — это стиль программирования, в котором программист описывает, что нужно сделать, а не как это сделать.


**Что за метод id()?**

Встроенная функция, который возвращает уникальный идентификатор объекта. Этот идентификатор является целым числом и соответствует адресу памяти, в котором объект хранится на момент вызова функции. Идентификатор уникален среди всех объектов в течении времени жизни этого объекта.



**Как dict и set реализованы внутри? Какова сложность получения элемента? Сколько памяти потребляет каждая структура?**
Словарь: хранит пары, ключ и значение. Внутренне словарь использует хэш-таблицу для быстрого поиска значений по ключу.  Каждый ключ в словаре представляет собой объект, и для каждого ключа вычисляется хэш с помощью функции hash(). Этот хэш используется для определения индекса, по которому ключ и его значение будут храниться в массиве.

Множества: хранит ключ. Внутренне множества использует хэш-таблицу для быстрого поиска значений по ключу.  Каждый ключ представляет собой объект, и для каждого объекта вычисляется хэш с помощью функции hash().

Обработка коллизий. Коллизии — это когда два ключа имеют одинаковый кэш. Решается: 

- открытой адресацией, когда ищется следующая свободная ячейка в таблице. 

- метод цепочек, в каждой ячейки хэш-таблицы хранятся списки объектов с одинаковым хэш значением и при коллизии новый элемент добавляется в конец списка.

- перехеширование: при заполнении таблицы или возникновении большого числа коллизий размер таблицы увеличивается, и данные перераспределяются с использованием новой хэш-функции.

Сложность получения, вставки и удаления в среднем О(1).

Каждая структура потребляет памяти О(n), где n количество элементов в словаре или количество элементов в множестве. 

Как в словаре происходит удаление элемента?
Когда в Python из словаря удаляют элемент, происходит нечто похожее на удаление страницы из книги, но при этом важно, чтобы страницы, которые были до и после удаленной, оставались связаны и не потерялись.

Объясню проще: словарь помнит порядок добавления элементов, потому что каждый элемент "знает", кто был до него и кто после него. Когда удаляется элемент, Python не просто вычеркивает его, а перенастраивает связи так, чтобы предыдущий и следующий элементы оказались связаны напрямую.

Представь цепочку из звеньев. Если одно звено убрать, его соседи связываются сразу друг с другом, чтобы цепочка осталась целой и порядок не нарушился.

Внутри словаря это значит:

- Находит удаляемый элемент в таблице по ключу.
- Убирает его из таблицы.
- Меняет ссылки соседних элементов в связном списке, чтобы "пропустить" удаленный.
- Так упорядоченность словаря сохраняется, и при итерации по нему элементы идут в том же порядке.

Это нужно, чтобы сохранить порядок элементов и иметь быстрый доступ по ключам.

Так что "перекручивание ссылок" — это перестановка связей между соседними элементами, чтобы цепь не прервалась, несмотря на удаление. Когда словарь удаляет элемент, он находит его в своей внутренней структуре (по ключу) и убирает эту пару ключ-значение. Но чтобы сохранить известный порядок элементов, словарь использует цепочку (связный список), где каждый элемент знает, кто был до него и кто после.

При удалении элемента программа перестраивает эту цепочку — соединяет предыдущий и следующий за удаляемым элемент с помощью обновления ссылок, чтобы "перекрыть" место удалённого и не разорвать порядок.



**Отличие __init__ и __new__?**
Вызывается первым, до создания объекта / Вызывается вторым, после создания объекта.

Создает новый объект. / Инициализирует созданный объект.

Должен вернуть новый объект. / Не должен ничего возвращать

Используем __new__, если нужно создать объект / Используем __init__, если нужно инициализировать объект после его создания. 

__new__: 

- Статический метод класса
- Отвечает за СОЗДАНИЕ объекта
- Возвращает сам экземпляр класса
- Вызывается ПЕРЕД созданием объекта
- Работает с классом, а не с инстансом
- Может изменить процесс создания объекта
- Может вернуть объект другого типа

- __init__: 
  - Метод экземпляра класса
  - Отвечает за ИНИЦИАЛИЗАЦИЮ объекта
  - НЕ возвращает значение (всегда None)
  - Вызывается ПОСЛЕ создания объекта
  - Работает с уже созданным объектом
  - Настраивает состояние объекта
  - Получает уже готовый экземпляр класса


**classmethod и staticmethod?**
Декораторы@classmethodи@staticmethodв Python используются для изменения способа вызова методов в классе.@classmethodпозволяет методу получать доступ к самому классу через параметрcls, тогда как@staticmethodне принимает ни экземпляр, ни класс в качестве первого параметра, работая как обычная функция, но в контексте класса.

Таким образом, @classmethod полезен, если нужен доступ к состоянию класса, а @staticmethod — когда метод связан по смыслу с классом, но не нуждается ни в экземпляре, ни в классе.



***args и **kwargs?**
*args для передачи произвольного количества позиционных аргументов в функцию. Собирает аргументы в кортеж.

` `**kwargs для передачи произвольного количества именованных аргументов с ключами в функцию. Собирает аргументы в словарь.



**Что такое аннотации типов, зачем они нужны и когда применяются?**
Это механизм, который позволяет явно указывать типы переменных, аргументов функций и их возвращаемых значений. Применяется, когда нужна ясность (понимание, что ожидается), при работе в команде (влияет на качество кода, делает его понятным), для сложных проектов (много кода, помогает отслеживать типы и избегать несоответствий).

Таким образом, аннотации помогают писать более надежный и понятный код, особенно в крупных проектах. Аннотации типов в Python — это механизм, позволяющий явно указывать типы переменных, аргументов функций и их возвращаемых значений. Они нужны для повышения ясности кода, удобства понимания, особенно при работе в команде и в больших проектах, где важно отслеживать типы данных и избегать ошибок.

Аннотации дают подсказки разработчикам и инструментам (редакторам, линтерам), но не влияют на выполнение программы. Их применяют, чтобы сделать код более читаемым, поддерживаемым и надежным. Например, указывают, что функция принимает целые числа и возвращает строку — это помогает сразу понять, что ожидается и что возвращается


**Что такое Замыкания?**
Функция, которая находится внутри другой функции и ссылается на переменные, которые объявлены в теле внешней функции.


**Как аргументы передаются в функции: по значению или по ссылке?**
Аргументы передаются по ссылке на объект. Если объект изменяемый, то изменения будут видны за пределами функции. Если объект неизменяемый, то функция не может изменить оригинальный объект.


**3 часть. 14**

**globals() и locals()**

globals() возвращает словарь, содержащий все глобальные переменные, доступные в текущей области видимости, включая встроенные переменные.

locals() возвращает словарь, содержащий все локальные переменные, определенные в текущей области видимости. Это включает аргументы функции и переменные, которым присвоено значение внутри функции.


**Назови четыре парадигмы ООП и как ты их понимаешь?**

Наследование – создание класса на основе существующего. Новый класс – это подкласс, наследует свойства и методы родительского класса (переиспользует код).

Полиморфизм – объекты разных классов могут использовать одинаковые методы с разной реализацией.

Инкапсуляция – скрытие деталей реализации объекта от внешнего мира. В языке Python достигается через соглашения о «защищённых» (_protected) и «приватных» (__private, с искажением имени) атрибутах и методах, которые не должны использоваться напрямую извне.

Абстракция - описание только важных деталей, без реализации.

Абстракция — это как упрощение сложной вещи до самых важных частей, чтобы было проще с ней работать и понимать ее. Представьте, что вы водите машину. Чтобы поехать, вам не нужно знать, как именно работает двигатель или как устроена коробка передач. Вам важно только, что есть руль, педали и кнопки, которыми вы управляете. Это и есть абстракция — вы видите только ключевые элементы и не вникаете в детали.

Пример в программировании:
Есть абстрактный класс "Транспортное средство" с методами "ехать" и "остановиться". Конкретные классы, например "Машина" и "Велосипед", реализуют эти методы по-своему. Пользователь работает с транспортным средством через общий интерфейс (ехать, остановиться), не думая о том, как это устроено внутри.

Таким образом, абстракция помогает скрыть сложные детали, показывая только функционал, который действительно важен для взаимодействия с объектом. Это делает программы проще, понятнее и удобнее для работы

Класс – шаблон для создания объектов.

Объект (инстанс) – экземпляр класса, имеющий свойства (атрибуты) и методы (действия).


**super().method_name(arguments)**

**Встроенная функция в Python, которая позволяет вызывать методы родительского класса в порядке MRO.**

**Дескрипторы** 

это специальный объект, который управляет доступом к атрибутам других объектов. Если вы видите магические методы __get__, __set__ или __delete__ в классе, значит, это дескриптор. Гет – доступ к атрибуту, сет – присвоение значения атрибуту. 

**Mixin**

это "**надстройка**" для классов, чтобы добавлять (*mix - подмешивать*) новые возможности через множественное наследование.

**Diamond problem – ромбовидное наследование.**

Возникает в ООП при множественном наследии. Она представляет собой неопределенность, которая возникает, когда класс наследуется от двух или более базовых классов, которые имеют общий предок.

Решается проблема с помощью MRO (Method Resolution Order). Когда вы вызываете метод у экземпляра класса, Python следует порядку, который определяет, какой метод будет выбран. Чтобы посмотреть, какой порядок разрешения применяется в классе, можно использовать метод mro().

**Что такое метакласс?**

это классы для создания других классов. Если класс создает объект, то метакласс создает класс.

Зачем нужны метаклассы?

Контроль за созданием классов.

Автоматическая модификация классов.

Добавление методов или атрибутов ко всем создаваемым классам.


**DRY, KISS, YAGNI**

DRY (Don't Repeat Yourself) - Не повторяйся. Каждый элемент знаний должен иметь единственное, недвусмысленное представление в системе.

KISS (Keep It Simple, Stupid) - Держи это простым. Системы работают лучше, если они просты, а не усложнены.

YAGNI (You Aren't Gonna Need It) - Вам это не понадобится. Не добавляйте функциональность, пока она не стала абсолютно необходимой.

**Приведи пример паттерна проектирования**

Singleton (Одиночка) Гарантирует, что у класса есть только один экземпляр.

Пример: Класс для управления подключением к базе данных.

Observer (Наблюдатель)

Определяет зависимость "один ко многим" между объектами, при которой изменение состояния одного объекта приводит к автоматическому уведомлению и обновлению всех зависимых объектов.

Пример: Подписка на обновления данных.

Factory Method (Фабричный метод)

Описание: Определяет интерфейс для создания объектов, но позволяет подклассам изменить тип создаваемого объекта.

Пример: Создание различных типов документов.

**Что такое HTTP?**

HTTP (HyperText Transfer Protocol) — это протокол прикладного уровня для передачи данных в сети, используемый для общения между веб-браузерами и серверами.


**Метод (HTTP Method):** 

Определяет действие, которое клиент хочет выполнить. Основные методы включают:

`   `- GET: Запрос данных с сервера. Обычно используется для получения страниц или ресурсов.

`   `- POST: Отправка данных на сервер, чаще всего для создания или обновления ресурса. Не является идемпотентным

`   `- PUT: Обновление существующего ресурса на сервере. Если ресурс существует, он обновляется; если нет, создается. Идемпотентный

`   `- DELETE: Удаление ресурса с сервера.

`   `- PATCH: Частичное обновление ресурса.

Идемпотентный — это такой метод или операция, при повторном выполнении которого результат не меняется, как если бы его выполнили только один раз.

Пример из жизни: представьте кнопку вызова лифта на этаже. Когда вы нажимаете эту кнопку, лифт приезжает. Если нажать кнопку снова и снова, лифт не начнет ездить туда-сюда — он уже вызван и приедет один раз. То есть повторные нажатия не изменят ситуацию. Это и есть идемпотентность.

В HTTP:

- GET, PUT, DELETE — идемпотентные методы. Например, если несколько раз подряд отправить запрос DELETE для удаления одного и того же ресурса, ресурс после первого запроса удалится, а последующие запросы не изменят состояние — ресурс уже удален.
- POST — неидемпотентный, потому что при повторных запросах может создаваться несколько ресурсов (например, добавление товара в корзину).

Идемпотентность важна для устойчивости систем: если соединение оборвалось, клиент может безопасно повторить запрос без риска нежелательных изменений.



**О-нотация (Big O notation)**

Способ оценки алгоритмической сложности алгоритма в терминах его временных или пространственных характеристик

O(1) – константное время.

O(log n) - логарифмическое время. Время выполнения алгоритма увеличивается логарифмически по отношению к размеру входных данных (бинарный поиск).

O(n) – линейное время.

O(n log n) — линейно-логарифмическое время. Время выполнения алгоритма растет растет пропорционально произведению размера входных данных на логарифм этого размера. Пример: сортировка слиянием.

O(n^2) — квадратичное время. Время выполнения алгоритма растет как квадрат размера входных данных. Пример: вложенный цикл, где каждый элемент массива сравнивается с каждым другим элементом.

O(2^n) — экспоненциальное время. Время выполнения алгоритма растет экспоненциально по отношению к размеру входных данных. Пример: рекурсивный алгоритм, который решает задачу путем разделения ее на подзадачи.

O(n!) — факториальное время. Время выполнения алгоритма растет как факториал размера входных данных. Пример: задача коммивояжера, где необходимо найти самый короткий маршрут, проходящий через все города.


**Функции в Python** — это объекты (наследники object), содержащие фрагменты кода, которые можно вызывать по имени, чтобы выполнить определенное действие. Параметры — это переменные, указанные при создании функции. Аргументы — это значения, которые передаются в функцию при её вызове. Параметры обязательные def func(param1), со значение по умолчанию def func (param1 = None), Произвольное количество аргументов def func(*args, **kwargs). 

Порядок аргументов сначала идут обычные параметры. Затем args. Потом именованные параметры. И в конце *kwargs. def my_function(a, b, *args, key1=None, **kwargs)

Для объяснения работы функции используется строка документации (**docstring**). Она пишется сразу после объявления функции в тройных кавычках. **Функция высшего порядка** — это функция, которая: **принимает другие функции как аргументы**, или **возвращает другую функцию** как результат.

**Разница между deep copy и обычным copy**

- Обычный copy (shallow copy): 
  - Создаёт новый объект, но копирует ссылки на внутренние объекты
  - new_list = list.copy() или new_list = list[:]
  - Вложенные объекты остаются связанными с оригиналом
- Deep copy: 
  - Рекурсивно копирует все вложенные объекты, создаются новые ссылки
  - Нужен модуль copy: import copy; new_list = copy.deepcopy(list)
  - Полностью независимая копия, изменения во вложенных объектах не влияют на оригинал

Когда использовать:

- Shallow copy: для плоских структур или когда связь вложенных объектов не критична
- Deep copy: когда нужна полная независимость копии, включая все вложенные объекты


Основные паттерны проектирования ООП

Python из коробки поддерживает несколько шаблонов проектирования, которые встроены в сам язык или стандартную библиотеку. Вот основные паттерны:

**Порождающие паттерны**

- **Одиночка (Singleton)** - реализуется через модули Python (модуль загружается один раз)
- **Фабричный метод** - через классы-фабрики и функции-фабрики
- **Итератор** - встроен в язык через протокол итераторов и генераторы

**Структурные паттерны**

- **Декоратор** - встроенные декораторы функций (@property, @classmethod и т.д.)
- **Адаптер** - часто используется в стандартной библиотеке для совместимости
- **Заместитель (Proxy)** - например, в модуле multiprocessing.Manager

**Поведенческие паттерны**

- **Наблюдатель (Observer)** - сигналы и слоты в библиотеке asyncio
- **Стратегия** - функции как объекты первого класса
- **Цепочка ответственности** - через исключения и их обработку
- **Шаблонный метод** - через абстрактные базовые классы (ABC)
- **Итератор** - протокол итераторов, генераторы и конструкция yield
- **Посредник (Mediator)** - например, в модуле asyncio

**Другие встроенные паттерны**

- **Контекстный менеджер** - паттерн через оператор with и протокол __enter__/__exit__
- **Дескрипторы** - специальные классы с методами __get__, __set__, __delete__
- **Метаклассы** - для создания фабрик классов

В стандартной библиотеке Python многие из этих паттернов используются и комбинируются для создания гибких абстракций, особенно в таких модулях как collections, functools, itertools и contextlib.


**Что такое Git и зачем он нужен?**

**Git** — это распределенная система контроля версий, которая отслеживает изменения в файлах и позволяет работать над проектом совместно с другими разработчиками. 

Преимущества: хранение истории изменений, возможность отката к любой версии, параллельная работа над проектом, резервное копирование кода.

**Gitflow** - это методология ветвления и управления версиями в Git.

**Ветка** — это независимая линия разработки. Ветки позволяют параллельно работать над разными задачами.

Популярная модель ветвления: main — основная ветка, develop — ветка разработки, feature/* — ветки для новых функций, release - ветки, создаваемые для подготовки к выпуску новой версии, hotfix/* — ветки для срочных исправлений.

**Как у вас была устроена разработка с точки зрения GIT?**

какой флоу у вас был? Самая классика, на мой взгляд, - это FeatureDevelopment.

Начало работы с новым проектом:

1. Создаем новый проект на GitHub 

2. Клонируем его локально git clone

3. Создаем новую ветку для работы git checkout -b feature/registration

4. Работаем над кодом... 

5. Добавляем изменения и создаем коммит git add.

6. Отправляем изменения на GitHub git push origin feature/registration	

Ежедневная работа с существующим проектом:

1. Получаем последние изменения из main - git checkout main или git pull origin main

2. Создаем новую ветку для задачи git checkout -b fix/login-bug

3. Работаем над задачей... 

4. Проверяем какие файлы изменились git status

5. Смотрим изменения в коде git diff

6. Добавляем и коммитим изменения git add . и git commit -m "fix: исправлена ошибка авторизации"

7. Получаем последние изменения из main git checkout main git pull origin main

8. Возвращаемся в свою ветку и обновляем её git checkout fix/login-bug git rebase main

9. Отправляем изменения git push origin fix/login-bug

**git fetch vs git pull**

Git fetch origin обновляет локальную копию удаленного репозитория, не меняя состояние файлов проекта.

Git pull origin <название ветки> получение и слияние изменений из удаленного репозитория. Эта команда комбинирует git fetch (получение изменений) и git merge (слияние изменений).

**git merge vs git rebase**

git merge <ваша ветка> слияние веток в вашем репозитории.

**git rebase:** переносит коммиты из одной ветки в другую, создавая новые коммиты. История коммитов становится линейной и более чистой, но может вызвать конфликты.

**Как создать новую ветку в Git?**

git checkout -b branch_name

**Как выполнить коммит в Git?**

git commit -m 'message'

**git cherry-pick**

Выбирает определенные коммиты по их хэшу и применяет их к текущей ветке.

git cherry-pick <хэш-коммита>

**Как добавить изменения в индекс перед коммитом?**

Добавление изменений в индекс для подготовки к коммиту. Выборочное добавление файлов в индекс осуществляется с использованием этой команды.

 Добавить все изменения в индекс git add .

 Добавить конкретный файл в индекс git add <имя файла>




**Что такое Docker и для чего он используется?**

это платформа для контейнеризации, которая позволяет упаковывать приложение со всеми его зависимостями в стандартизированный блок (контейнер) для разработки, доставки и запуска.

Компоненты:

**Dockerfile**: инструкции для сборки образа

**Image**: шаблон для создания контейнера

**Container**: запущенный экземпляр образа

**Registry**: хранилище образов (например, Docker Hub)

**Как создать образ Docker?**

Образ Docker создается с использованием Dockerfile, который содержит инструкции для пошагового построения образа, включая базовый образ, зависимости и настройки.

#### Используем базовый образ
FROM ubuntu:20.04

#### Устанавливаем необходимые пакеты
RUN apt-get update && apt-get install -y
python3 
python3-pip

#### Создаем рабочий каталог
WORKDIR /app

#### Копируем файлы в контейнер
COPY . /app

#### Устанавливаем зависимости Python
RUN pip3 install -r requirements.txt

#### Определяем переменные среды
ENV APP_PORT=8000

#### Открываем порт
EXPOSE $APP_PORT

#### Команда, которая будет выполнена при запуске контейнера
CMD ["python3", "app.py"]

**Что такое Docker Compose и как он упрощает развертывание многоконтейнерных приложений?**

Инструмент для определения и управления многоконтейнерных приложений через файл конфигурации YAML, что позволяет легко запускать и масштабировать связанные службы.

**Что такое Docker Hub?**

это облачный реестр образов Docker, где разработчики могут публиковать, обмениваться и загружать готовые образы для использования в своих проектах.

**Как вы решали проблемы сбоев в работе контейнеров?**

Для решения проблем сбоев в работе контейнеров, часто используются инструменты мониторинга, логирования и анализа журналов, а также детальное изучение выводов команд docker logs и docker inspect.

**Какие инструменты мониторинга и логирования Docker вы предпочитаете и почему?**

Примеры могут включать Prometheus для мониторинга метрик и Grafana для визуализации, а также ELK (Elasticsearch, Logstash, Kibana) стек для логирования.

**Чем отличаются контейнеры от виртуальных машин?**

Контейнеры используют общую операционную систему и изолируют приложения, что делает их легковесными и быстрыми в запуске. 

Виртуальные машины (ВМ) включают полноценную операционную систему поверх гипервизора, что приводит к большему потреблению ресурсов и времени на запуск. 

Контейнеры обеспечивают изоляцию на уровне процессов, ВМ — на уровне оборудования.

Контейнеры: лучше всего подходят для разработки, тестирования и развертывания микросервисов, а также для сценариев, требующих быстрого развертывания и масштабирования.

Виртуальные машины: предпочтительнее для приложений, требующих полной изоляции и контроля над программным обеспечением и конфигурацией операционной системы.

Вкратце:

- **Виртуальные машины (ВМ)**используют гипервизор и включают полноценную гостевую ОС, что обеспечивает сильную изоляцию, но требует больше ресурсов и времени на запуск.
- **Контейнеры**используют общую ОС-хоста, создавая изолированные среды для процессов, что даёт минимальный overhead, быстрый старт и удобство в масштабировании.

**Где лучше использовать контейнеры**

- Разработка и тестирование микросервисов
- CI/CD pipelines и DevOps сценарии
- Быстрый деплой и частые обновления
- Горизонтальное масштабирование (динамичные нагрузки)

**Где лучше использовать виртуальные машины**

- Запуск приложений с нестандартными или конфликтующими системными требованиями
- Изоляция приложений с высокими требованиями к безопасности
- Полноценная эмуляция разных операционных систем
- Legacy-приложения, которые зависят от конкретной ОС














