```shell
# Показывает адрес удаленного репозитория (origin)
git remote -v
```

### git pull
Для того, чтобы синхронизироваться с удаленным репозиторием, стянув оттуда свежие изменения, есть  
команда `git pull`. Так как под капотом она выполняет `git fetch` и `git merge`, то могут возникнуть  
две ситуации: Fast Forward Merge и Merge Commit.
1. Если master/main ушла вперед относительно моей ветки (т.е. у меня еще не было коммитов),  
то при`git pull` произойдет FF merge и моя ветка сместится на последний коммит master/main, будто  
я создал ветку от последнего коммита
2. Если коммиты были в обеих ветках, то произойдет Merge Commit на мою ветку. В этом мердже может  
случиться конфликт, если коммиты из удаленной ветки меняли те же файлы в тех же строках, что и мои.  
И устранение таких конфликтов может быть очень долгим и утомительным.

Для того, чтобы избегать таких ситуаций с конфликтами, есть более аккуратный путь.
Для начала нужно прервать текущий конфликтный мёрдж:
```shell
git merge --abort
```
и перейти к дальнейшим шагам.

### git fetch
Эта команда просто стягивает изменения с репозитория, но не применяет их, т.е. не делает `git merge`  
```shell
git fetch
git fetch origin
```
После того, как мы получили изменения мы можем посмотреть были ли коммиты в удаленной ветке:
```shell
# Покажет скачанные коммиты origin/master
git log master..origin/master

# Если нахожусь в master
git log HEAD..origin/master

# Покажет список измененных файлов
git diff --stat master origin/master
```
А после и разницу между состоянием нашего и удаленного репозитория:
```shell
# Сравнивает изменения рабочего каталога с origin/master
git diff origin/master

# Сравнивает изменения локальной main ветки с origin/master
# Ветка это тот же коммит. По сути мы сравниваем коммиты
git diff main origin/master
```
Мы видим какие отличия в файлах и, где будет потенциальный конфликт. Подправляем свой файл, если требуется,  
выполняем мёрдж и пушим на сервер:
```shell
git merge origin/master
git push
```
